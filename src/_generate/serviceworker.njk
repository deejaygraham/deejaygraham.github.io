---
permalink: /sw.js
eleventyExcludeFromCollections: true
excludeFromSitemap: true
---
// service worker code based on the example https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers
// some other ideas from https://github.com/bnijenhuis/bnijenhuis-nl and https://gomakethings.com/how-to-set-an-expiration-date-for-items-in-a-service-worker-cache/

// change version to allow upgrade
const CACHE_VERSION = '-v1b';
const CACHE_NAME = 'core' + CACHE_VERSION;
const CACHING_DURATION = 24 * 3600;
const CACHE_EXPIRY_HEADER = 'SW-Cache-Expires';
const DEBUG = true;

// pages
const offlinePage = '/offline.html';
const searchDatabase = '/search-index.json';
const siteStylesheet = '/css/site.css';
const notFoundPage = '/404.html'
const coreAssets = [
      "/index.html",
      siteStylesheet,
      "/favicon.ico",
      "/img/favicon.png",
      "/img/avatar.svg",
      offlinePage,
      searchDatabase,
      notFoundPage
];

addEventListener('install', function (event) {
    event.waitUntil(
        caches.open(CACHE_NAME).then(function (cache) {
            try {
                // add all at once
                cache.addAll(coreAssets);
            } catch {
                console.error('sw: cache.addAll');
                for (let asset of coreAssets) {
                    try {
                        cache.add(asset);
                    } catch (error) {
                        console.warn('sw: cache.add', asset);
                        console.warn('sw: ', error);
                    }
                }
            }
        })
    );
});

addEventListener('activate', function (event) {
    event.waitUntil(
        caches.keys().then(function (keys) {
            return Promise.all(keys
                .filter(key => key !== CACHE_NAME)
                .map(key => caches.delete(key))
            )
        })
    )
});

addEventListener('fetch', function (event) {
    if (event.request.method !== "GET") {
        return;
    }

    // (directly) respond with cached asset (if available)
    event.respondWith(serveFromCache(event, { ignoreSearch: false, checkExpiryHeader: false }));

    // serve from network
    // event.respondWith(serveFromNetwork(event.request));

    // update cache (only if in core assets)
    if (coreAssets.includes(event.request.url)) {
       event.waitUntil(updateCache(event.request, CACHE_NAME));
    }
});

/**
 * serve request from cache
 * if file isn't cached longer than 24 hours, it's still valid
 * @param {Request} the request object
 * @param {Boolean} ignoreSearch if true, ignore search parameters in request
 * @param {Boolean} checkExpiryHeader if true, check for custom expiry header
 * @return {Object} response object from cache or from fetch
 */
function serveFromCache(request, { ignoreSearch, checkExpiryHeader } = {}) {
    var matchOptions = {};
    if (ignoreSearch) matchOptions = { ignoreSearch: true };

    return caches.match(request, matchOptions).then(function (cacheResponse) {
        // if found return cache
        if (cacheResponse) {
            if (checkExpiryHeader) {
                if (isCacheResponseStillValid(cacheResponse)) {
                    return cacheResponse;
                }
            } else {
                return cacheResponse;
            }
        }

        // fetch it again, because cache was not found or was expired
        return fetch(request).then(function (response) {
            if (request.url.includes(siteStylesheet)) {
                updateCache(request, CACHE_NAME);
            } 

            return response;
        }).catch(function () {
            if (request.url.endsWith('/')) {
                return caches.match(offlinePage);
            } 
        });
    })
}

/**
 * Serve request from network
 *
 * @param {Request} the request object
 * @return {Object} response object from fetch or from cache
 */
/* eslint-disable-next-line */
function serveFromNetwork(request) {
    return fetch(request).then(function (response) {
        if ((request.destination == 'document') && (response.status == 404)) {
            return caches.match(notFoundPage);
        }

        return response;

    }).catch(function () {
        return caches.match(request).then(function (cacheResponse) {
            if (cacheResponse) {
                return cacheResponse;
            }

            if (request.destination == 'document') {
                return caches.match(notFoundPage);
            }
        }).catch(function () {
            if (request.destination == 'document') {
                return caches.match(notFoundPage);
            }
        });
    });
}

/**
 * update cache
 * @param {Object} request the event request
 * @param {String} cacheName the cache to update
 * @return {Object} response object
 */
function updateCache(request, cacheName) {
    return caches.open(cacheName).then(function (cache) {
        return fetch(request).then(function (response) {
            var responseCopy = response.clone();
            var headers = new Headers(responseCopy.headers);

            const expires = new Date();
            expires.setSeconds(expires.getSeconds() + CACHING_DURATION);

            headers.append(CACHE_EXPIRY_HEADER, expires.toUTCString());

            var requestKey = request;
            return responseCopy.blob().then(function (body) {
                return cache.put(requestKey, new Response(body, {
                    status: responseCopy.status,
                    statusText: responseCopy.statusText,
                    headers: headers
                }));
            });
        });
    });
}

/**
 * check of cacheResponse is still valid
 * if file isn't cached longer than 24 hours, it's still valid
 * @param {Object} cacheResponse the cacheResponse object
 * @return {Boolean} if true, cacheResponse is valid
 */
function isCacheResponseStillValid(cacheResponse) {
    if (!cacheResponse) {
        return false;
    }

    var fetched = cacheResponse.headers.get(CACHE_EXPIRY_HEADER);

    const expirationDate = Date.parse(fetched);
    return expirationDate > Date.now(); 
};
