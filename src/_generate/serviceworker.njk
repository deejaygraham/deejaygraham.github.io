---
permalink: /sw.js
eleventyExcludeFromCollections: true
excludeFromSitemap: true
---
// service worker code for site
// based on the example https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers
// some other ideas from https://github.com/bnijenhuis/bnijenhuis-nl 
// and https://gomakethings.com/how-to-set-an-expiration-date-for-items-in-a-service-worker-cache/

// change version to allow upgrade
const CACHE_VERSION = '-v1a';
const CACHE_NAME = 'core' + CACHE_VERSION;
// How long to cache - 24 hours here
const CACHING_DURATION = 24 * 3600;
const CACHE_EXPIRY_HEADER = 'sw-fetched-on';
// Verbose logging or not
const DEBUG = true;

// pages
const offlinePage = '/offline.html';
const searchDatabase = '/search-index.json';
const siteStylesheet = '/css/site.css';
const notFoundPage = '/404.html'
const coreAssets = [
      "/index.html",
      siteStylesheet,
      "/favicon.ico",
      "/img/favicon.png",
      "/img/avatar.svg",
      offlinePage,
      searchDatabase,
      notFoundPage
];

// install service worker and cache core assets
addEventListener('install', function (event) {
    event.waitUntil(
        caches.open(CACHE_NAME).then(function (cache) {
            DEBUG && console.log('Adding core assets to cache');

            try {
                // add all at once
                cache.addAll(coreAssets);
            } catch {
                // may fail, attempt add invidually
                console.error('sw: cache.addAll');
                for (let asset of coreAssets) {
                    try {
                        cache.add(asset);
                    } catch (error) {
                        console.warn('sw: cache.add', asset);
                        console.warn('sw: ', error);
                    }
                }
            }
        })
    );
});

// make sure to remove old caches
addEventListener('activate', function (event) {
    DEBUG && console.log('Deleting old cache data');
    event.waitUntil(
        caches.keys().then(function (keys) {
            return Promise.all(keys
                .filter(key => key !== CACHE_NAME)
                .map(key => caches.delete(key))
            )
        })
    )
});

// fetch assets and serve from cache and update cache
addEventListener('fetch', function (event) {
    // ignore anything that's not a GET
    if (event.request.method !== "GET") {
        DEBUG && console.log(event.request.method, 'ignoring cached version');
        return;
    }

    DEBUG && console.log('fetch', event.request.url);

    if (event.request.url.includes(siteStylesheet)) {
        // (directly) respond with cached asset (if available)
        DEBUG && console.log('requesting stylesheet', event.request.url); 
        event.respondWith(serveFromCache(event, { ignoreSearch: true, checkExpiryHeader: false }));

        // serve from network
        //event.respondWith(serveFromNetwork(event));

        // update cache
        event.waitUntil(updateCache(event.request, CACHE_NAME));

    } else {
        // (directly) respond with cached asset (if available)
        event.respondWith(serveFromCache(event, { ignoreSearch: false, checkExpiryHeader: false }));

        // serve from network
        // event.respondWith(serveFromNetwork(event));

        // update cache (only if in core assets)
        if (coreAssets.includes(event.request.url)) {
            event.waitUntil(updateCache(event.request, CACHE_NAME));
        }
    }
});

/**
 * serve request from cache
 * if file isn't cached longer than 24 hours, it's still valid
 * @param {Event} event the request event
 * @param {Boolean} ignoreSearch if true, ignore search parameters in request
 * @param {Boolean} checkExpiryHeader if true, check for custom expiry header
 * @return {Object} response object from cache or from fetch
 */
function serveFromCache(event, { ignoreSearch, checkExpiryHeader } = {}) {
    // set the right match options
    var matchOptions = {};
    if (ignoreSearch) matchOptions = { ignoreSearch: true };

    DEBUG && console.log('Attempting to serve from cache', event.request.url);

    return caches.match(event.request, matchOptions).then(function (cacheResponse) {
        // if found return cache
        if (cacheResponse) {
            console.debug('cached response exists');
            if (checkExpiryHeader) {
                DEBUG && console.log('checking for expiry');
                if (isCacheResponseStillValid(cacheResponse)) {
                    DEBUG && console.log('cached response is fresh');
                    return cacheResponse;
                }
                DEBUG && console.log('out of date');
            } else {
                DEBUG && console.log('returning cached version');
                return cacheResponse;
            }
        }

        DEBUG && console.log('fetching from network');
        // fetch it again, because cache was not found or was expired
        return fetch(event.request).then(function (response) {
            if (event.request.url.includes(siteStylesheet)) {
                updateCache(event.request, CACHE_NAME);
            } 

            return response;

            // if offline and not found in cache, return offline data
        }).catch(function () {
            if (event.request.url.endsWith('/')) {
                return caches.match(offlinePage);
            } 
        });
    })
}

/**
 * Serve request from network
 *
 * @param {Event} event the request event
 * @return {Object} response object from fetch or from cache
 */
/* eslint-disable-next-line */
function serveFromNetwork(event) {
    console.debug('Attempting to serve from network', event.request.url);
    // try and get it from the network
    return fetch(event.request).then(function (response) {
        if ((event.request.destination == 'document') && (response.status == 404)) {
            return caches.match(notFoundPage);
        }

        return response;

    }).catch(function () {
        // try and get it from cache
        return caches.match(event.request).then(function (cacheResponse) {
            // if found return cache
            if (cacheResponse) {
                return cacheResponse;
            }

            // otherwise return 404 (if a document is requested)
            if (event.request.destination == 'document') {
                return caches.match(notFoundPage);
            }
        }).catch(function () {
            // otherwise return 404 (if a document is requested)
            if (event.request.destination == 'document') {
                return caches.match(notFoundPage);
            }
        });
    });
}

/**
 * update cache
 * @param {Object} request the event request
 * @param {String} cacheName the cache to update
 * @return {Object} response object
 */
function updateCache(request, cacheName) {
    DEBUG && console.log('caching', request.url);

    return caches.open(cacheName).then(function (cache) {
        return fetch(request).then(function (response) {
            var responseCopy = response.clone();
            var headers = new Headers(responseCopy.headers);
            headers.append('sw-fetched-on', new Date().getTime());

            var requestKey = request;
            DEBUG && console.log(headers);

            return responseCopy.blob().then(function (body) {
                return cache.put(requestKey, new Response(body, {
                    status: responseCopy.status,
                    statusText: responseCopy.statusText,
                    headers: headers
                }));
            });
        });
    });
}

/**
 * check of cacheResponse is still valid
 * if file isn't cached longer than 24 hours, it's still valid
 * @param {Object} cacheResponse the cacheResponse object
 * @return {Boolean} if true, cacheResponse is valid
 */
function isCacheResponseStillValid(cacheResponse) {
    if (!cacheResponse) {
        DEBUG && console.log('No response to check for header');
        return false;
    }

    var fetched = cacheResponse.headers.get(CACHE_EXPIRY_HEADER);
    DEBUG && console.log(fetched);

    const expirationDate = Date.parse(fetched);
    const now = new Date();

    DEBUG && console.log('Expiration', expirationDate);

    return expirationDate > now;
};
